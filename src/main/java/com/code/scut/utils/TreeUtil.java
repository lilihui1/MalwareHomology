package com.code.scut.utils;

import element.Edge;
import element.Graph;
import element.Node;
import element.style.node.NodeShape;
import net.sf.json.JSONObject;
import org.processmining.processtree.ProcessTree;

import java.util.*;

import static com.code.scut.Predict.Util.getBlockType;

/**
 * @ClassName TreeUtil
 * @Description 行为树的操作
 * @Author lilihui
 * @Date 2020/4/1 18:17
 * @Version 1.0
 */
public class TreeUtil {

    public static Map treeToJson(ProcessTree tree) {
        Map resultMap = new HashMap();
        resultMap.put("root",tree.getRoot().toString());
        HashSet<UUID> ids = new HashSet<UUID>();

        Set<Node> nodes = new HashSet<Node>();

        LinkedHashSet<Edge> edges = new LinkedHashSet<element.Edge>();
        HashMap<UUID,element.Node> map= new HashMap<UUID,element.Node>();
        HashMap<String, String> edgeMap = new  HashMap<String,String>();
        Set<org.processmining.processtree.Block> blocks= new HashSet<org.processmining.processtree.Block>();
        //块集合
        for(org.processmining.processtree.Edge e:tree.getEdges()) {
            blocks.add(e.getSource());
        }
        for(org.processmining.processtree.Block block:blocks) {
            String blockType = getBlockType(block.getClass());
            element.Node blockNode = new element.Node();
            if(block.getName().length()!=0) {
                blockNode.setLabel(block.getName());
            }else {
                blockNode.setLabel(blockType);
            }
            blockNode.setId(block.getID()+"");
            blockNode.setShape(NodeShape.circle);
            map.put(block.getID(), blockNode);
            for(org.processmining.processtree.Node n:block.getChildren()) {
                element.Node node;
                if(map.get(n.getID())==null) {
                    node = new element.Node();
                    node.setShape(NodeShape.box);
                    String nodeLabel = n.getName().length()==0?getBlockType(n.getClass()):n.getName();
                    NodeShape shape  = n.getName().length()==0?NodeShape.circle:NodeShape.box;
                    node.setLabel(nodeLabel);
                    node.setId(n.getID()+"");
                    node.setShape(shape);
                    map.put(n.getID(), node);
                }else {
                    node = map.get(n.getID());
                }
                System.out.println(blockNode.getLabel()+"->"+node.getLabel());

                Edge edge = new Edge();
                edge.setfrom(blockNode.getId());
                edge.setto(node.getId());
                edges.add(edge);
            }
        }
        Graph graph = new Graph(nodes, edges);
        graph.setTitle("行为树");
        for(element.Node node :map.values()) {
            nodes.add(node);
        }
        //graph.saveJsonFileToLocal("process_tree.json");

        resultMap.put("TreeJson",graph.transform2json());


       // return graph.transform2json();
        return resultMap;
    }
}
