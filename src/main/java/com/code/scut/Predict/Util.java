package com.code.scut.Predict;

import inductiveMiner.Miner;
import inductiveMiner.MiningParameters;
import inductiveMiner.MiningParametersIM;
import log.IMLog;
import log.IMLogImpl;
import org.deckfour.xes.in.XesXmlParser;
import org.deckfour.xes.model.XAttributeMap;
import org.deckfour.xes.model.XEvent;
import org.deckfour.xes.model.XLog;
import org.deckfour.xes.model.XTrace;
import org.deckfour.xes.model.impl.*;
import org.deckfour.xes.out.XesXmlSerializer;
import org.processmining.processtree.Block;
import org.processmining.processtree.Node;
import org.processmining.processtree.ProcessTree;

import java.io.*;
import java.util.*;

import static com.code.scut.utils.TreeUtil.treeToJson;

public class Util {
    //家族行为特征的存储地址
    //public static  String familyBehaviorDirPath = "E:\\家族行为特征";
    public static  String familyBehaviorDirPath = "/home/yushenglong/project/familyBehavior";
    //家族数字标号与其字符串map
    public static Map<Integer,String> familyIndexMap = new HashMap<>();
    //所有家族的行为权重Map
    public static Map<String,Map<String,Double>> allFamilyBehaviorWeightMap = new HashMap<>();
    public static  String testVectorPath = "test.txt";
    static{
        allFamilyBehaviorWeightMap = parseFamilyBehavior();
    }
    public static String predict(List<String> apiList){
        //1.生成相似度向量,保存在test.txt
        convertToSimilarityVector(apiList);
        //2.朴素贝叶斯预测
        Object ob =NaiveBayes.predict(testVectorPath);
        if(null==ob){
            System.err.println("预测失败");
            return null;
        }else{
            return familyIndexMap.get(Integer.parseInt(ob.toString()));
        }
    }
    /**
     * 生成样本的相似度向量，并存在本地
     * @param apiList
     * @return
     */
    public static void  convertToSimilarityVector(List<String> apiList) {
        /**样本的行为特征*/
        Set<String> behaviorSet = convertToBehaviors(apiList);

        StringBuffer stringBuffer = new StringBuffer();
        //新增一个缓存
        StringBuffer stringBuffer2 = new StringBuffer();

        int familyIndex = 0;
        double similarity;
        for(String family:allFamilyBehaviorWeightMap.keySet()){
            familyIndexMap.put(familyIndex,family.split("\\.txt")[0]);
            similarity = computeSetSimilarity(allFamilyBehaviorWeightMap.get(family),behaviorSet);
            /**与各个家族的相似度*/
            stringBuffer.append(similarity+" ");
            stringBuffer2.append(family+">"+similarity+";");

            familyIndex++;
        }
        //占位符
        stringBuffer.append("-1");
        FileUtil.writeFile(testVectorPath,stringBuffer.toString());
        FileUtil.writeFile("familySimilarity.txt",stringBuffer2.toString());
    }

    /**
     * 计算测试样本与某个家族之间的相似度
     * @param familyBehaviorWeightMap 家族的行为权重map
     * @param testSampleBehaviorSet 测试样本的行为集合
     * @return
     */
    public static double computeSetSimilarity(Map<String,Double> familyBehaviorWeightMap,Set<String> testSampleBehaviorSet){
        Set<String> familyBehaviorSet = familyBehaviorWeightMap.keySet();
        double sum = 0;
        double similaritySum =0;
        for(String behavior:familyBehaviorSet){
            sum+= familyBehaviorWeightMap.get(behavior);
            if(testSampleBehaviorSet.contains(behavior)){
                similaritySum += familyBehaviorWeightMap.get(behavior);
            }
        }

        return similaritySum/(sum);
    }
    /**
     * 从文件中解析家族行为特征
     * @return
     */
    public static Map<String,Map<String,Double>> parseFamilyBehavior(){
        Map<String,Map<String,Double>> familyBehaviorMap = new HashMap<>();
        File familyBehaviorDir = new File(familyBehaviorDirPath);
        String fileContent = "";
        String behaviors [];
        String family;
        //家族行为及权重map
        Map<String,Double> behaviorWeightMap;
        if(familyBehaviorDir.exists()){
            /**把目录里的txt全部读取到files[]里了*/
            File files[] = familyBehaviorDir.listFiles();
            for(File file:files){
                behaviorWeightMap = new HashMap<>();
                /**家族名称：family，内容：fileContent，家族行为特征：behaviors*/
                family = file.getName();
                fileContent = FileUtil.readFile(file.getAbsolutePath());
                behaviors = fileContent.split(";");
                System.out.println(family+"家族行为特征：");
                for(String behavior:behaviors){
                    //打印家族特征
                   // System.out.println(behavior);

                    String arr[] =behavior.split(":");
                    behaviorWeightMap.put(arr[0],Double.parseDouble(arr[1]));

                }
                familyBehaviorMap.put(family,behaviorWeightMap);
            }
            return familyBehaviorMap;
        }else{
            System.err.println("家族行为特征文件不存在");
            return  null;
        }
    }

    /**
     * 从API序列中获取行为
     */
    public static Set<String> convertToBehaviors(List<String> apiList){
        //转换成API日志
        String savedPath = "temp.txt";
        convertToXLog(apiList,savedPath);
        return getBehaviors(savedPath);
    }
    /**
     * 将API序列转换成API日志
     * @param apiList
     * @param xLogSavedPath
     */
    public static void convertToXLog(List<String> apiList, String xLogSavedPath){
        XLog log = new XLogImpl(new XAttributeMapImpl());
        XTrace trace = listToTrace(apiList);
        log.add(trace);
        saveXlogToLocal(log,xLogSavedPath);
    }
    public static XTrace listToTrace(List<String> apiList){
        XTrace trace = new XTraceImpl(new XAttributeMapImpl());
        XAttributeMap attrMap ;
        XEvent event;
        for(String api:apiList){
            attrMap = new XAttributeMapImpl();
            attrMap.put("concept:name", new XAttributeLiteralImpl("concept:name", api));
            event = new XEventImpl(attrMap);
            trace.add(event);
        }
        return trace;
    }

    /**
     * 保存API日志
     * @param log
     * @param xlogSavedPath
     */
    public static void saveXlogToLocal(XLog log, String xlogSavedPath) {
        File xesLogFile = new File(xlogSavedPath);
        try {
            if(xesLogFile.exists()){
                xesLogFile.delete();
            }
            xesLogFile.createNewFile();
            OutputStream out = new FileOutputStream(xesLogFile);
            XesXmlSerializer xesXmlSerializer = new XesXmlSerializer();
            xesXmlSerializer.serialize(log, out);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * 解析日志
     * @param path 日志路径
     * @return
     */
    public static XLog eventLogParse(String path) {
        File f = new File(path);
        InputStream input = null;
        try {
            input = new FileInputStream(f);
        } catch (FileNotFoundException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
        XLog xlog = null;
        XesXmlParser xxp = new XesXmlParser();
        List<XLog> listXLog = new ArrayList<XLog>();

        try {
            listXLog = xxp.parse(input);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        if (!listXLog.isEmpty()) {
            xlog = listXLog.get(0);
        }
        return xlog;
    }

    /**
     * 从API日志中获取行为
     * @param eventLogPath
     * @return
     */
    public static Set<String> getBehaviors(String eventLogPath){
        Set<String> behaviorSet = new HashSet<>();

        /**行为树*/
        ProcessTree tree = getProcessTree(eventLogPath);
        Map treeMap = treeToJson(tree);
        //String root = tree.getRoot().toString();
        //System.out.println("行为树root："+root);

        FileOutputStream fos = null;
        ObjectOutputStream oos = null;
        try {
            // 创建文件
            File file = new File("processTree.txt");
            if (file.exists() && file.isFile()) {
                file.delete();
            }
            file.createNewFile();

            fos = new FileOutputStream(file);
            oos = new ObjectOutputStream(fos);
            oos.writeObject(treeMap);
            oos.flush();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }


        List<String> apiNames = getApiNodes(tree);
        behaviorSet.addAll(apiNames);
        Set<org.processmining.processtree.Block> blocks= new HashSet<org.processmining.processtree.Block>();
        //块集合
        for(org.processmining.processtree.Edge e:tree.getEdges()) {
            blocks.add(e.getSource());
        }
        System.out.println("......");
        for(Block block:blocks){
            String behavior = block.toString();
            //去除掉噪声及空格
            behavior = filter(behavior);
            //System.out.println(behavior);
            if(behavior.length()!=0){
                behaviorSet.add(behavior);
            }
            List<Node> nodes = block.getChildren();
            List<String> nodesName = new ArrayList<>();
            for(int i = 0,size=nodes.size();i<size;i++){
                String nodeName = nodes.get(i).toString();
                //if(!nodeName.equals("tau")){
                nodesName.add(filter(nodes.get(i).toString()));
                //}
            }
            //根结点的类型
            String type = getBlockType(block.getClass());
            switch(type) {
                case "And":
                case "Xor":
                    //对子结点的名称进行排序
                    Collections.sort(nodesName);
                case "Seq":
                    for(int i = 0,size=nodesName.size();i<size;i++)
                        for(int j = i+1;j<size;j++){
                            String sub1 = nodesName.get(i).toString();
                            String sub2 = nodesName.get(j).toString();
                            behaviorSet.add(type+"("+sub1+","+sub2+")");
                        }
                    break;
                case "XorLoop":
                    //循环体
                    String sub1 = nodesName.get(0).toString();
                    for(int i =1,size= nodesName.size();i<size;i++){
                        String sub2 = nodesName.get(i).toString();
                        behaviorSet.add(type+"("+sub1+","+sub2+")");
                    }
                    break;
                default:
                    break;
            }
        }
       // System.out.println("样本行为特征：");
//        for(String behavior:behaviorSet){
//            System.out.println(behavior);
//        }
        return  behaviorSet;
    }

    /**
     * 挖掘行为树
     * @param eventLogPath
     * @return
     */
    public static ProcessTree getProcessTree(String eventLogPath){
        XLog xlog = eventLogParse(eventLogPath);
        MiningParameters parameters = new MiningParametersIM();

        parameters.setNoiseThreshold(0);
        IMLog log = new IMLogImpl(xlog, parameters.getClassifier(), parameters.getLifeCycleClassifier());
        ProcessTree tree = Miner.mine(log, parameters);
        return tree;
    }
    /**
     * 获取树上的所有API节点，API节点为叶子节点
     * @return
     */
    public static List<String> getApiNodes(ProcessTree tree){
        List<String> apiNodes = new ArrayList<String>();
        Set<org.processmining.processtree.Block> blocks= new HashSet<org.processmining.processtree.Block>();
        //块集合

        for(org.processmining.processtree.Edge e:tree.getEdges()) {
            blocks.add(e.getSource());
        }

        for(org.processmining.processtree.Block block:blocks) {
            String blockType = getBlockType(block.getClass());
            for(org.processmining.processtree.Node node:block.getChildren()) {
                if(node.getName().length() != 0 && !node.getName().equals("tau")) {

                    apiNodes.add(node.getName());
                }
            }
        }
        return apiNodes;
    }

    /**
     * 过滤空格
     * @param name
     * @return
     */
    public static String filter(String name){
        return name.replaceAll(" ","");
    }
    /**
     * 获取block的类型
     * @param block
     * @return
     */
    public static String getBlockType(Class block) {
        String className = block.toString();
        int index = className.indexOf("$");
        if(index!=-1) {
            return className.substring(index+1);
        }
        return "";
    }
}
